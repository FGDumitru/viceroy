<?php

namespace Viceroy\Tools;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\GuzzleException;
use Viceroy\Connections\Definitions\OpenAICompatibleEndpointConnection;
use Viceroy\Tools\Interfaces\ToolInterface;

/**
 * Enhanced GetRedditHot tool with advanced functionality including:
 * - Direct XML RSS parsing (no LLM dependency)
 * - Multiple sort types support (hot, new, top, rising)
 * - LLM-based content and comment summarization
 * - Sentiment analysis for content and comments
 * - Comprehensive caching mechanism
 * - Robust error handling and validation
 */
class GetRedditHot implements ToolInterface
{
    private Client $httpClient;
    private array $cache = [];
    private int $cacheTtl;

    // Valid sort types for Reddit RSS feeds
    private const VALID_SORT_TYPES = ['hot', 'new', 'top', 'rising'];
    
    // Cache keys
    private const CACHE_PREFIX_RSS = 'rss_';
    private const CACHE_PREFIX_CONTENT = 'content_';
    private const CACHE_PREFIX_COMMENTS = 'comments_';
    private const CACHE_PREFIX_SENTIMENT = 'sentiment_';

    /**
     * Constructor with optional parameters for automatic tool discovery compatibility
     */
    public function __construct(
        ?Client $httpClient = null,
        int $cacheTtl = 300 // 5 minutes default cache TTL
    ) {
        $this->httpClient = $httpClient ?? new Client([
            'timeout' => 10.0,
            'http_errors' => false,
            'headers' => [
                'User-Agent' => 'Mozilla/5.0 (compatible; Viceroy-RedditTool/1.0)',
                'Accept' => 'application/rss+xml, application/xml, text/xml',
            ]
        ]);
        $this->cacheTtl = $cacheTtl;
    }

    public function getName(): string
    {
        return 'get_reddit_hot';
    }

    public function getDefinition(): array
    {
        return [
            'type' => 'function',
            'function' => [
                'name' => 'get_reddit_hot',
                'description' => 'Fetches Reddit posts with advanced analysis including content summarization, comment summarization, and sentiment analysis.',
                'parameters' => [
                    'type' => 'object',
                    'properties' => [
                        'subreddit' => [
                            'type' => 'string',
                            'description' => 'The subreddit name (without r/ prefix). Defaults to "hot" posts from Reddit front page.',
                            'default' => ''
                        ],
                        'sort_type' => [
                            'type' => 'string',
                            'description' => 'Sort type for posts: hot, new, top, rising. Defaults to "hot".',
                            'enum' => self::VALID_SORT_TYPES,
                            'default' => 'hot'
                        ],
                        'limit' => [
                            'type' => 'integer',
                            'description' => 'Maximum number of posts to fetch and analyze. Defaults to 5.',
                            'default' => 5,
                            'minimum' => 1,
                            'maximum' => 25
                        ],
                        'include_content_analysis' => [
                            'type' => 'boolean',
                            'description' => 'Whether to fetch and analyze linked content. Defaults to true.',
                            'default' => true
                        ],
                        'include_comment_analysis' => [
                            'type' => 'boolean',
                            'description' => 'Whether to fetch and analyze comments. Defaults to true.',
                            'default' => true
                        ],
                        'include_sentiment_analysis' => [
                            'type' => 'boolean',
                            'description' => 'Whether to perform sentiment analysis on content and comments. Defaults to true.',
                            'default' => true
                        ]
                    ],
                    'required' => []
                ]
            ]
        ];
    }

    public function validateArguments(array $arguments): bool
    {
        // Validate sort_type
        if (isset($arguments['sort_type'])) {
            if (!is_string($arguments['sort_type']) || 
                !in_array($arguments['sort_type'], self::VALID_SORT_TYPES, true)) {
                return false;
            }
        }

        // Validate subreddit
        if (isset($arguments['subreddit'])) {
            if (!is_string($arguments['subreddit'])) {
                return false;
            }
            // Basic subreddit name validation (alphanumeric, underscores, hyphens)
            if (!empty($arguments['subreddit']) && 
                !preg_match('/^[a-zA-Z0-9_-]+$/', $arguments['subreddit'])) {
                return false;
            }
        }

        // Validate limit
        if (isset($arguments['limit'])) {
            if (!is_int($arguments['limit']) || 
                $arguments['limit'] < 1 || 
                $arguments['limit'] > 25) {
                return false;
            }
        }

        // Validate boolean parameters
        foreach (['include_content_analysis', 'include_comment_analysis'] as $param) {
            if (isset($arguments[$param]) && !is_bool($arguments[$param])) {
                return false;
            }
        }

        return true;
    }

    public function execute(array $arguments, $configuration): array
    {
        if (!$this->validateArguments($arguments)) {
            return $this->createErrorResponse('Invalid arguments provided.');
        }

        try {
            // Set default values
            $subreddit = $arguments['subreddit'] ?? '';
            $sortType = $arguments['sort_type'] ?? 'hot';
            $limit = $arguments['limit'] ?? 5;
            $includeContentAnalysis = $arguments['include_content_analysis'] ?? true;
            $includeCommentAnalysis = $arguments['include_comment_analysis'] ?? true;
            $includeSentimentAnalysis = $arguments['include_sentiment_analysis'] ?? true;

            // Fetch RSS feed
            $rssData = $this->fetchRssFeed($subreddit, $sortType);
            if (!$rssData) {
                return $this->createErrorResponse('Failed to fetch Reddit RSS feed.');
            }

            // Parse RSS and extract posts
            $posts = $this->parseRssFeed($rssData, $limit);
            if (empty($posts)) {
                return $this->createErrorResponse('No posts found in RSS feed.');
            }

            // Enhance posts with analysis
            $enhancedPosts = [];
            foreach ($posts as $post) {
                $enhancedPost = $post;

                // Content analysis
                if ($includeContentAnalysis && !empty($post['link'])) {
                    $enhancedPost['content_summary'] = $this->analyzeContent($post['link'], $configuration);
                    if ($includeSentimentAnalysis) {
                        // If content analysis failed, use description for sentiment
                        $sentimentText = $enhancedPost['content_summary'];
                        if (strpos($sentimentText, 'not accessible') !== false || strpos($sentimentText, 'failed') !== false) {
                            $sentimentText = $post['description'] ?? '';
                        }
                        $enhancedPost['content_sentiment'] = $this->analyzeSentiment($sentimentText, $configuration);
                    } else {
                        $enhancedPost['content_sentiment'] = 'Sentiment analysis disabled';
                    }
                } else {
                    $enhancedPost['content_summary'] = 'Content analysis disabled';
                    if ($includeSentimentAnalysis) {
                        // Use description for sentiment if content analysis is disabled
                        $enhancedPost['content_sentiment'] = $this->analyzeSentiment($post['description'] ?? '', $configuration);
                    } else {
                        $enhancedPost['content_sentiment'] = 'Sentiment analysis disabled';
                    }
                }

                // Comment analysis
                if ($includeCommentAnalysis && !empty($post['comments_link'])) {
                    $enhancedPost['comments_summary'] = $this->analyzeComments($post['comments_link'], $configuration);
                    if ($includeSentimentAnalysis) {
                        // If comment analysis failed, use description for sentiment
                        $sentimentText = $enhancedPost['comments_summary'];
                        if (strpos($sentimentText, 'not accessible') !== false || strpos($sentimentText, 'failed') !== false) {
                            $sentimentText = $post['description'] ?? '';
                        }
                        $enhancedPost['comments_sentiment'] = $this->analyzeSentiment($sentimentText, $configuration);
                    } else {
                        $enhancedPost['comments_sentiment'] = 'Sentiment analysis disabled';
                    }
                } else {
                    $enhancedPost['comments_summary'] = 'Comment analysis disabled';
                    if ($includeSentimentAnalysis) {
                        // Use description for sentiment if comment analysis is disabled
                        $enhancedPost['comments_sentiment'] = $this->analyzeSentiment($post['description'] ?? '', $configuration);
                    } else {
                        $enhancedPost['comments_sentiment'] = 'Sentiment analysis disabled';
                    }
                }

                $enhancedPosts[] = $enhancedPost;
            }

            return [
                'content' => [
                    [
                        'type' => 'text',
                        'text' => json_encode([
                            'posts' => $enhancedPosts,
                            'metadata' => [
                                'subreddit' => $subreddit ?: 'frontpage',
                                'sort_type' => $sortType,
                                'limit' => $limit,
                                'total_posts' => count($enhancedPosts),
                                'fetched_at' => date('c')
                            ]
                        ], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES)
                    ]
                ],
                'isError' => false
            ];

        } catch (\Exception $e) {
            return $this->createErrorResponse("Execution error: {$e->getMessage()}");
        }
    }

    /**
     * Fetch RSS feed from Reddit
     */
    private function fetchRssFeed(string $subreddit, string $sortType): ?string
    {
        $cacheKey = self::CACHE_PREFIX_RSS . md5($subreddit . $sortType);
        
        // Check cache first
        if ($this->isCached($cacheKey)) {
            return $this->getCached($cacheKey);
        }

        try {
            // Build RSS URL
            if (empty($subreddit)) {
                $url = "https://old.reddit.com/{$sortType}.rss";
            } else {
                $url = "https://old.reddit.com/r/{$subreddit}/{$sortType}.rss";
            }

            $response = $this->httpClient->get($url);
            
            if ($response->getStatusCode() !== 200) {
                throw new \RuntimeException("HTTP {$response->getStatusCode()}: Failed to fetch RSS feed");
            }

            $content = $response->getBody()->getContents();
            
            // Cache the result
            $this->setCache($cacheKey, $content);
            
            return $content;

        } catch (GuzzleException $e) {
            throw new \RuntimeException("Network error fetching RSS feed: {$e->getMessage()}");
        }
    }

    /**
     * Parse RSS feed and extract post information
     */
    private function parseRssFeed(string $rssData, int $limit): array
    {
        $posts = [];
        
        try {
            // Disable libxml errors and handle them manually
            libxml_use_internal_errors(true);
            
            $xml = simplexml_load_string($rssData);
            if (!$xml) {
                $errors = libxml_get_errors();
                libxml_clear_errors();
                throw new \RuntimeException("XML parsing failed: " . implode(', ', array_map(fn($e) => $e->message, $errors)));
            }

            // Extract posts from Atom entries (Reddit uses Atom format)
            $items = $xml->entry ?? [];
            $count = 0;

            foreach ($items as $item) {
                if ($count >= $limit) {
                    break;
                }

                // Extract basic post information from Atom format
                $title = (string) $item->title;
                $link = (string) $item->link["href"];
                $description = (string) $item->content;
                $pubDate = (string) $item->published;
                
                // Parse description for additional details
                $postData = $this->parseRedditDescription($description);
                
                $post = [
                    'title' => html_entity_decode($title, ENT_QUOTES | ENT_HTML5, 'UTF-8'),
                    'link' => $link,
                    'score' => $postData['score'] ?? 0,
                    'comments' => $postData['comments'] ?? 0,
                    'comments_link' => $postData['comments_link'] ?? '',
                    'author' => $postData['author'] ?? 'unknown',
                    'subreddit' => $postData['subreddit'] ?? 'unknown',
                    'category' => $postData['category'] ?? '',
                    'published_at' => $pubDate,
                    'description' => html_entity_decode(strip_tags($description), ENT_QUOTES | ENT_HTML5, 'UTF-8')
                ];

                $posts[] = $post;
                $count++;
            }

            return $posts;

        } catch (\Exception $e) {
            throw new \RuntimeException("RSS parsing error: {$e->getMessage()}");
        }
    }

    /**
     * Parse Reddit description HTML to extract structured data
     */
    private function parseRedditDescription(string $description): array
    {
        $data = [
            'score' => 0,
            'comments' => 0,
            'comments_link' => '',
            'author' => 'unknown',
            'subreddit' => 'unknown',
            'category' => ''
        ];

        try {
            // Use regex to extract data from the description
            // Score pattern: <span>Score: 1234</span>
            if (preg_match('/<span[^>]*>Score:\s*(\d+)<\/span>/i', $description, $matches)) {
                $data['score'] = (int) $matches[1];
            }

            // Comments pattern: <a href="...">1234 comments</a>
            if (preg_match('/<a[^>]*href="([^"]*)"[^>]*>(\d+)\s+comments<\/a>/i', $description, $matches)) {
                $data['comments'] = (int) $matches[2];
                $data['comments_link'] = html_entity_decode($matches[1], ENT_QUOTES | ENT_HTML5, 'UTF-8');
            }

            // Author pattern: submitted by <a href="...">author</a>
            if (preg_match('/submitted by\s+<a[^>]*>([^<]+)<\/a>/i', $description, $matches)) {
                $data['author'] = html_entity_decode($matches[1], ENT_QUOTES | ENT_HTML5, 'UTF-8');
            }

            // Subreddit pattern: to <a href="...">r/subreddit</a>
            if (preg_match('/to\s+<a[^>]*>r\/([^<]+)<\/a>/i', $description, $matches)) {
                $data['subreddit'] = html_entity_decode($matches[1], ENT_QUOTES | ENT_HTML5, 'UTF-8');
            }

            // Category/domain pattern: <a href="...">domain.com</a> <span>(category)</span>
            // Look for span that contains parentheses with content
            if (preg_match('/<span[^>]*>\(([^)]+)\)<\/span>/i', $description, $matches)) {
                $data['category'] = html_entity_decode($matches[1], ENT_QUOTES | ENT_HTML5, 'UTF-8');
            }

        } catch (\Exception $e) {
            // If parsing fails, return default values
        }

        return $data;
    }

    /**
     * Analyze content of a linked URL using LLM
     */
    private function analyzeContent(string $url, $configuration): string
    {
        $cacheKey = self::CACHE_PREFIX_CONTENT . md5($url);
        
        if ($this->isCached($cacheKey)) {
            return $this->getCached($cacheKey);
        }

        try {
            // Create a new connection for content analysis
            // Extract config from connection object if needed
            $config = $configuration;
            if ($configuration instanceof \Viceroy\Connections\Definitions\OpenAICompatibleEndpointConnection) {
                $config = $configuration->getConfiguration();
            }
            $analysisConnection = new \Viceroy\Connections\Definitions\OpenAICompatibleEndpointConnection($config);
            
            $prompt = "Please visit and analyze the content at this URL: {$url}\n\n" .
                     "Provide a concise summary of the main content in 2-3 sentences. " .
                     "Focus on the key information, main points, or overall topic. " .
                     "If the content is inaccessible or not text-based, respond with 'Content not accessible'.";

            $response = $analysisConnection->queryPost($prompt);
            $summary = $response->getLlmResponse();

            // Cache the result
            $this->setCache($cacheKey, $summary);

            return $summary;

        } catch (\Exception $e) {
            return "Content analysis failed: {$e->getMessage()}";
        }
    }

    /**
     * Analyze comments from a Reddit comments page using LLM
     */
    private function analyzeComments(string $commentsUrl, $configuration): string
    {
        $cacheKey = self::CACHE_PREFIX_COMMENTS . md5($commentsUrl);
        
        if ($this->isCached($cacheKey)) {
            return $this->getCached($cacheKey);
        }

        try {
            // Fetch the actual RSS feed for comments by appending .rss
            $rssUrl = $commentsUrl . ".rss";
            
            $response = $this->httpClient->get($rssUrl);
            if ($response->getStatusCode() !== 200) {
                $errorMsg = "Comments analysis failed: Unable to fetch comments RSS feed (HTTP " . $response->getStatusCode() . ")";
                $this->setCache($cacheKey, $errorMsg);
                return $errorMsg;
            }

            $rssContent = $response->getBody()->getContents();
            
            // Parse the RSS feed
            libxml_use_internal_errors(true);
            $xml = simplexml_load_string($rssContent);
            if (!$xml) {
                $errors = libxml_get_errors();
                libxml_clear_errors();
                $errorMsg = "Comments analysis failed: XML parsing failed - " . implode(", ", array_map(fn($e) => $e->message, $errors));
                $this->setCache($cacheKey, $errorMsg);
                return $errorMsg;
            }

            // Extract comments from the RSS feed
            $comments = [];
            $entries = $xml->entry ?? [];
            
            foreach ($entries as $entry) {
                if (isset($entry->content)) {
                    $commentText = (string) $entry->content;
                    $commentText = html_entity_decode(strip_tags($commentText), ENT_QUOTES | ENT_HTML5, "UTF-8");
                    if (!empty(trim($commentText))) {
                        $comments[] = $commentText;
                    }
                }
            }

            $commentCount = count($comments);
            
            if ($commentCount === 0) {
                $result = "Comments analysis: No comments found";
                $this->setCache($cacheKey, $result);
                return $result;
            }

            // Create a new connection for sentiment analysis
            $config = $configuration;
            if ($configuration instanceof ViceroyConnectionsDefinitionsOpenAICompatibleEndpointConnection) {
                $config = $configuration->getConfiguration();
            }
            $analysisConnection = new ViceroyConnectionsDefinitionsOpenAICompatibleEndpointConnection($config);
            
            // Prepare comments for analysis (limit to first 20 comments to avoid token limits)
            $commentsText = implode("

", array_slice($comments, 0, 20));
            
            $prompt = "Analyze these " . $commentCount . " Reddit comments and provide:
" .
                     "1. Overall sentiment: (positive, negative, neutral, or mixed)
" .
                     "2. Main themes/topics discussed
" .
                     "3. General consensus or controversy level
" .
                     "4. Brief summary in 2-3 sentences

" .
                     "Comments to analyze:
" . $commentsText . "

" .
                     "Please format your response as a concise analysis covering these points.";

            $response = $analysisConnection->queryPost($prompt);
            $sentimentAnalysis = $response->getLlmResponse();

            // Combine count and sentiment analysis
            $result = "Comments analysis: Found " . $commentCount . " comments. " . $sentimentAnalysis;
            
            // Cache the result
            $this->setCache($cacheKey, $result);

            return $result;

        } catch (GuzzleHttpExceptionGuzzleException $e) {
            $errorMsg = "Comments analysis failed: Network error - " . $e->getMessage();
            $this->setCache($cacheKey, $errorMsg);
            return $errorMsg;
        } catch (Exception $e) {
            $errorMsg = "Comments analysis failed: " . $e->getMessage();
            $this->setCache($cacheKey, $errorMsg);
            return $errorMsg;
        }
    }

    /**
     * Perform sentiment analysis on text using LLM
     */
    private function analyzeSentiment(string $text, $configuration): string
    {
        if (empty($text) ||
            strpos($text, 'not accessible') !== false ||
            strpos($text, 'failed') !== false) {
            return 'neutral';
        }

        $cacheKey = self::CACHE_PREFIX_SENTIMENT . md5($text);
        
        if ($this->isCached($cacheKey)) {
            return $this->getCached($cacheKey);
        }

        try {
            $prompt = "Analyze the sentiment of the following text and respond with ONLY ONE WORD: 'positive', 'negative', or 'neutral'.\n\n" .
                     "Text: {$text}\n\n" .
                     "Sentiment:";

            // Create a new connection for sentiment analysis
            // Extract config from connection object if needed
            $config = $configuration;
            if ($configuration instanceof \Viceroy\Connections\Definitions\OpenAICompatibleEndpointConnection) {
                $config = $configuration->getConfiguration();
            }
            $sentimentConnection = new \Viceroy\Connections\Definitions\OpenAICompatibleEndpointConnection($config);
            $response = $sentimentConnection->queryPost($prompt);
            $sentiment = strtolower(trim($response->getLlmResponse()));

            // Validate response
            if (!in_array($sentiment, ['positive', 'negative', 'neutral'])) {
                $sentiment = 'neutral';
            }

            // Cache the result
            $this->setCache($cacheKey, $sentiment);

            return $sentiment;

        } catch (\Exception $e) {
            return 'neutral';
        }
    }

    /**
     * Check if cache entry exists and is valid
     */
    private function isCached(string $key): bool
    {
        if (!isset($this->cache[$key])) {
            return false;
        }

        $entry = $this->cache[$key];
        return (time() - $entry['timestamp']) < $this->cacheTtl;
    }

    /**
     * Get cached value
     */
    private function getCached(string $key): string
    {
        return $this->cache[$key]['value'] ?? '';
    }

    /**
     * Set cache value
     */
    private function setCache(string $key, string $value): void
    {
        $this->cache[$key] = [
            'value' => $value,
            'timestamp' => time()
        ];
    }

    /**
     * Create standardized error response
     */
    private function createErrorResponse(string $message): array
    {
        return [
            'content' => [
                [
                    'type' => 'text',
                    'text' => "Error: {$message}"
                ]
            ],
            'isError' => true
        ];
    }
}
